# 图的深度优先遍历
##### 问题描述

分别用邻接矩阵和邻接链表两种数据结构实现图的深度优先遍历算法，输出遍历的结点序列，并分析算法的时间复杂度。 

提交格式： 

邻接矩阵数据结构实现void solveA(int n, int m, int e[][2], int out[])函数。 

邻接链表数据结构实现void solveB(int n, int m, int e[][2], int out[])函数。 

参数n为结点个数，m为边条数，e为所有边，out为输出序列。1<=n<=3000,1<=m<=100000,0<=e[i]\[j]<n。 

遍历的起始结点为0，邻接矩阵数据结构中按行从左到右遍历邻居结点，邻接链表数据结构中按存储顺序遍历邻居结点，图为无向图。 

请不要printf输出任何内容。 

输入样例： 

```
n=5,m=10,e={{2,4},{3,0},{0,2},{3,1},{4,1},{0,1},{3,4},{2,3},{1,2},{0,4}} 
```

输出样例： 

```
solveA：out={0,1,2,3,4} 
solveB：out={0,3,1,4,2}
```

#####  **核心思路**

1. 每种solve里都需调用相应的create和dfs;
2. 实现相应的create和dfs；
3. 构造主函数进行调试。

##### **实现要点**

1. 动态分配内存创建数组；
2. 函数间参数的传递；
3. visited[]的初始化；
4. 非连通图的考虑；
5. 邻接表深度遍历时的回退。

